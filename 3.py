'''
Сформувати функцію для обчислення індексу максимального елемента масиву n*n, де 1<=n<=5.
Огороднік Марина Олександрівна, І курс, група 122А
'''
'''
У даному випадку доцільніше використовувати функцію з ітерацією, тому що час розробки менший у порівнянні з рекурсією;
читабельність краща у випадку з ітерацією; час виконання функцій практично однаковий (у випадку ітерації трохи швидше);
пам'ять (стек) у випадку з рекурсіює використовується не доцільно, тому що значення кожного елемента заноситься у стек.
'''
import numpy as np  # імпортуємо бібліотеку numpy для роботи з масивами
import timeit  # імпортуємо модуль для обрахунку часу роботи функцій
from random import randint  # імпортуємо функцію для генерування цілих випадкових чисел
def max_rec(N, n, i = 0, j = 0, i1 = 0, j1 = 0):
    ''' Функція для обчислення індексу максимального елемента масиву n*n за допомогою рекурсії

    :param N: вихідний масив
    :param n: розмір масиву
    :param i: значення рядка масиву, який проходиться під час рекурсії
    :param j: значення стовпця масиву, який проходиться під час рекурсії
    :param i1: значення рядка масиву для максимального елемента при поточному виклику рекурсії
    :param j1: значення стовпця масиву для максимального елемента при поточному виклику рекурсії
    :return: кортеж, який складається з індексів максимального елемента масиву
    '''
    if i < n:  # визначення випадку, коли завершиться рекурсія (останній елемент масиву)
        if A[i][j] > A[i1][j1]:  # якщо знайдений більший елемент, то змінюємо значеня індексів максимального елемента
            i1, j1 = i, j
        if j + 1 < n:  # визначаємо чи переходити до наступного елемента, чи до наступного рядка
            return max_rec(N, n, i, j + 1, i1, j1)
        else:
            return max_rec(N, n, i + 1, 0, i1, j1)
    else:
        return i1, j1

def max_iter(M, n):
    ''' Функція для обчислення індексу максимального елемента масиву n*n за допомогою ітерації

    :param M: вихідний масив
    :param n: розмір масиву
    :return: кортеж, який складається з індексів максимального елемента масиву
    '''
    max_i, max_j = 0, 0  # вводимо змінні для визначення індексів максимального елемента
    max_val = 0  # вводимо змінну для визначення значення максимального елемента
    for i in range(n):  # циклічно обходимо всі елементи масиву
        for j in range(n):
            if M[i][j] > max_val:
                max_val, max_i, max_j = M[i][j], i, j
    return max_i, max_j

while True:
    while True:
        try:  # перевірка на правильність введення даних
            n = int(input('Input the array size: '))   # ведення розміру масиву n*n
            if 1 <= n <= 5:   # виключення випадку, що користувач введе число не в межах від 1 до 5
                break
            else:
                print('The number must be 1 <= n <= 5')
        except ValueError:
            print('It is not a number')
    A = np.zeros((n, n), dtype=int)  # ініціалізуємо пустий масив розміру n*n нулями
    for i in range(n):  # циклічно заповнюємо елементи масиву
        for j in range(n):
            A[i][j] = randint(-10, 10)  # заповнюємо масив рандомними числами в межах від -10 до 10
    print(A)  # вивоимо масив на екран
    # виводимо результат і час виконання функції
    print(f'Recursion: \nIndex of max element = {max_rec(A, n)} '
          f'\ntime = {timeit.timeit("max_rec(A, n)", setup="from __main__ import max_rec, A, n", number=1000)}')
    print(f'Iteration: \nIndex of max element = {max_iter(A, n)} '
          f'\ntime = {timeit.timeit("max_iter(A, n)", setup="from __main__ import max_iter, A, n", number=1000)}')

    # запитуємо кристувача чи продовжувати роботу далі, чи завершити програму
    answer = input('Do you want to continue (+) or complete the program (anything)? ')
    if answer == '+':
        continue
    else:
        break